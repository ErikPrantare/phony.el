;;; phony.el --- Speech bindings for Elisp           -*- lexical-binding: t; -*-

;; Copyright (C) 2024, 2025 Erik Präntare

;; Author: Erik Präntare
;; Keywords: files
;; Version: 0.1.0
;; Homepage: https://github.com/ErikPrantare/phony.el
;; Package-Requires: ((emacs "28.1"))
;; Created: 13 Jul 2024

;; This program is free software; you can redistribute it and/or
;; modify it under the terms of the GNU Affero General Public License
;; as published by the Free Software Foundation, either version 3 of
;; the License, or (at your option) any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU Affero General Public
;; License along with this program.  If not, see
;; <http://www.gnu.org/licenses/>.

;;; Commentary:

;;

;;; Code:

(require 'cl-lib)
(require 'subr-x)

(defgroup phony nil
  "Functionality for defining speech bindings."
  :group 'files)

(defcustom phony-output-directory (locate-user-emacs-file "phony")
  "Directory for files generated by phony."
  :type 'directory
  :group 'phony)

(defun phony--output-directory (&rest components)
  "Get path to output directory.

If provided, COMPONENTS are appended as components in the returned path."
  (apply
   #'file-name-concat
   (expand-file-name phony-output-directory)
   components))

(defun phony--to-python-identifier (symbol)
  "Generate a fitting python identifier for SYMBOL.

This function is used to automatically generate external names for
rules."
  (concat "phony_" (replace-regexp-in-string (rx (not alnum)) "_" (symbol-name symbol))))

(cl-defstruct (phony--rule
               (:constructor nil))
  "A rule for matching an utterance.

NAME is the name of the rule.

EXTERNAL-NAME is the name this rule will have for the speech recognition
engine, and should be a string."
  (name nil :type symbol)
  (external-name nil :type string))

(cl-defstruct (phony--procedure-rule
               (:include phony--rule))
  (function '() :type function)
  (element nil :type phony--element-sequence)
  (arglist '() :type (repeat symbol))
  (export t :type boolean)
  (modes '(global) :type (repeat symbol))
  (anchor-beginning-p nil :type boolean)
  (anchor-end-p nil :type boolean))

(cl-defstruct (phony--open-rule
               (:include phony--rule))
  (alternatives nil :type (repeat symbol))
  (transformation nil :type function))

(cl-defstruct (phony--dictionary
               (:include phony--procedure-rule)
               (:constructor nil)
               (:constructor phony--make-dictionary
                             (name
                              &key
                              (external-name (phony--to-python-identifier name))
                              format-raw-p)))
  "A dictionary mapping utterances to values.

NAME must be the symbol containing the mapping, an alist.

FORMAT-RAW-P is t if this dictionary is intended to be used on the
speech recognition side.  In that case, the mapping may only map to
strings."
  (format-raw-p nil :type boolean))

(defun phony--dictionary-alist (dictionary)
  "Return the alist stored in DICTIONARY."
  (funcall (phony--dictionary-name dictionary)))

(defun phony--normalize-rule (rule-or-name)
  "Return rule specified by RULE-OR-NAME.
RULE-OR-NAME must be a `phony--rule' or a symbol naming a rule."
  (if (symbolp rule-or-name)
      (phony--get-rule rule-or-name)
    rule-or-name))

(defun phony--external-name (rule-or-name)
  "Return the external name for RULE-OR-NAME.

The external name of a rule is a string, representing how the function
is identified when exported to the speech engine."
  (phony--rule-external-name
   (phony--normalize-rule rule-or-name)))

(defvar phony--rules (make-hash-table)
  "Hash table of all defined rules, indxed by name.")

(defun phony--get-rules ()
  "Return a list containing all defined rules."
  (hash-table-values phony--rules))

(defun phony--get-rule (name)
  "Get the rule named NAME.
Return nil if no such rule exists."
  (gethash name phony--rules))

(defun phony--add-rule (rule)
  "Add a new rule RULE.

This function must be invoked every time a rule is defined."
  (puthash (phony--rule-name rule)
           rule
           phony--rules))

(defun phony-remove-rule (rule-name)
  "Remove rule named RULE-NAME."
  (interactive (list (intern (completing-read "Remove rule: "
                                              (hash-table-keys
                                               phony--rules)))))
  (remhash rule-name phony--rules)
  (seq-doseq (open-rule (seq-filter
                         #'phony--open-rule-p
                         (phony--get-rules)))
    (setf (phony--open-rule-alternatives open-rule)
          (remove rule-name (phony--open-rule-alternatives open-rule))))
  (phony-request-export))

(defun phony-dictionary-get (utterance dictionary)
  "Return the value corresponding to UTTERANCE in DICTIONARY.
If no such value exists, return nil."
  (funcall dictionary utterance))

(defmacro phony-dictionary-put (utterance dictionary value)
  "Set the value of UTTERANCE in DICTIONARY to VALUE.
If value is nil, remove the utterance from the list instead.

Invoking this function will resync the dictionary to the external speech
recognition engine."
  (declare (indent defun))
  `(prog1
       (setf (alist-get ,utterance ,dictionary nil t #'equal) ,value)
     (phony--request-export-dictionaries)))

(gv-define-expander phony-dictionary-get
  ;; We need to use `gv-define-expander', because the simpler versions
  ;; expand to a let-expression binding the dictionary to a local
  ;; variable.  That meant removing  became impossible.
  (lambda (do utterance dictionary)
    (funcall do `(phony-dictionary-get ,utterance ,dictionary)
             (lambda (value)
               `(phony-dictionary-put ,utterance ,dictionary ,value)))))

(defun phony--create-lookup-representation (entry dictionary)
  "Create lookup string for ENTRY in DICTIONARY.

When evaluating the returned string from emacsclient, this performs
the lookup."
  (if (phony--dictionary-format-raw-p dictionary)
      (cdr entry)
    (format "(%s \"%s\")"
            (phony--dictionary-name dictionary)
            (car entry))))

(defun phony--prepare-dictionary-for-serialization (dictionary)
  "Return DICTIONARY as an entry for `json-serialize'.

This represents one key-value pair, mapping the external dictionary name
to its dictionary."
  (cons (make-symbol (phony--external-name dictionary))
        (mapcar (lambda (entry)
                  (cons
                   (make-symbol (car entry))
                   ;; Each value is a string, encoding a form that
                   ;; will evaluate to the actual value.
                   (phony--create-lookup-representation
                    entry dictionary)))
                (phony--dictionary-alist dictionary))))

;; TODO: Handle IO errors
(defun phony--export-dictionaries ()
  "Write dictionaries to dictionaries.json.

The speech recognition backend can read this file to register the
dictionaries."
  (with-temp-file (phony--output-directory "dictionaries.json")
    (json-insert
     (mapcar #'phony--prepare-dictionary-for-serialization
             (seq-filter #'phony--dictionary-p (phony--get-rules))))))

(defun phony--request-export-dictionaries ()
  "Sync DICTIONARY-NAMES when next idle."
  (interactive)
  (cancel-function-timers #'phony--export-dictionaries)
  (run-with-idle-timer 0.0 nil #'phony--export-dictionaries))

(cl-defun phony--define-dictionary (name
                                    mapping
                                    &key
                                    (external-name nil)
                                    (format-raw nil))
  "Define dictionary rule NAME containing MAPPING.

If provided, EXTERNAL-NAME specifies the name that the rule will go
under for the external speech engine.  If FORMAT-RAW is t, the
dictionary will be formated for use on the side of the speech
recognition engine.  This only works if the values of the dictionary are
strings."
  (setq external-name (or external-name
                          (phony--to-python-identifier name)))

  (unless (proper-list-p mapping)
    (error "The mapping of %s must be a list" name))

  (when-let ((non-cons (seq-find (lambda (x) (not (consp x))) mapping)))
    (error "The mapping of %s must be a alist, but %S is not a cons cell"
           name non-cons))

  (when-let ((non-string-key (seq-find
                              (lambda (entry) (not (stringp (car-safe entry))))
                              mapping)))
    (error "The keys of %s must be strings, but %S is not a string"
           name (car non-string-key)))

  (defalias name
    (lambda (&optional utterance new-value)
      (:documentation (concat "Return the alist of dictionary `"
                              (symbol-name name)
                              "'.\nIf UTTERANCE is given, return instead the corresponding value of the
alist.  If NEW-VALUE is provided as well, associate instead UTTERANCE
to NEW-VALUE in this dictionary."))
      (if utterance
          (if new-value
              (setf (alist-get utterance (symbol-value name) nil nil #'equal)
                    new-value)
            (alist-get utterance (symbol-value name) nil nil #'equal))
        (symbol-value name))))

  (eval `(gv-define-simple-setter ,name ,name))

  (phony--add-rule
   (phony--make-dictionary
    name
    :external-name external-name
    :format-raw-p format-raw))
  (phony--request-export-dictionaries)

  ;; Needs to return the actual mapping, see `phony-define-dictionary'
  mapping)

(defun phony--split-keywords-rest (declaration-args)
  "Split DECLARATION-ARGS into keyword arguments and rest arguments.

Keyword arguments are assumed to occur first.  Returns a cons-cell with
the car being a plist of the keyword arguments and the cdr the rest
arguments."
  (let ((arguments '()))
    (while (keywordp (car declaration-args))
      (push (seq-take declaration-args 2) arguments)
      (setq declaration-args (seq-drop declaration-args 2)))
    (cons (apply #'append arguments) declaration-args)))

(defmacro phony-define-dictionary (name &rest arguments)
  ;; checkdoc-params: (arguments)
  "Define a dictionary with NAME and containing ALIST.

ALIST is an alist mapping utterances to values.  An utterance is a
string containing the spoken form for referencing the value.  The
defined rule matches on any of the keys and evaluates to the
corresponding value.

Optional arguments are given as named arguments before ALIST.  They can
be one of the following:

  :external-name    Name to expose to the external engine.
  :format-raw       Export values in a form usable by the engine,
                    not Emacs.  This only works when the values are
                    strings.

\(fn NAME [KEY VALUE]... ALIST)"
  (declare (indent defun))
  (let ((split-arguments (phony--split-keywords-rest arguments)))
    ;; We need to expand to defvar, or else xref will not find the
    ;; definition.  defvar only modifies the variable when it is void,
    ;; so if it is not we revert to setq.
    ;; TODO: Remove the variable definition
    `(,(if (boundp name) 'setq 'defvar)
      ,name
      (phony--define-dictionary ',name ,@(cdr split-arguments) ,@(car split-arguments)))))

(defun phony--add-alternative (alternative open-rule-name)
  "Add rule ALTERNATIVE as an alternative for open rule OPEN-RULE-NAME."
  (let ((rule (phony--get-rule open-rule-name)))
    (unless rule
      (error "No rule %s defined" open-rule-name))
    (unless (phony--open-rule-p rule)
      (error "No open rule %s defined" open-rule-name))
    (cl-pushnew alternative (phony--open-rule-alternatives rule))))

(cl-defmacro phony-define-open-rule (name &key
                                          (alternatives nil)
                                          (contributes-to nil)
                                          (transformation nil)
                                          (external-name nil))
  "Define NAME as an open rule.

Open rules match any of the rules specified in ALTERNATIVES.  Other
rules can contribute to the list of alternatives through their
CONTRIBUTES-TO argument.

CONTRIBUTES-TO is an open rule or a list of open rules that this rule
contributes to.  See also `phony-rule', which admits this argument as
well.

If a function TRANSFORMATION is given, the value of the matched
alternative is first passed through TRANSFORMATION to create the value
of matching this rule.  Otherwise, the value is passed through without
modification.

If EXTERNAL-NAME is given, it will be used for the name generated for
this rule in the external speech engine."
  (declare (indent defun))
  `(progn
     (cl-assert (symbolp ,transformation) nil
                "Argument transformation must be a symbol")

     ;; For finding the definition of this rule
     (defalias ',name #'ignore
       "Open rule for phony.")

     (phony--add-rule
      (make-phony--open-rule
       :name ',name
       :external-name ,(or external-name (phony--to-python-identifier name))
       :transformation ,transformation
       :alternatives ,alternatives))

     (seq-doseq (to (ensure-list ,contributes-to))
       (phony--add-alternative ',name to))

     ',name))

(cl-defstruct phony--element-literal
  "Element matching a literal utterance."
  (string nil
          :type string
          :documentation "Utterance that matches this element."))

(cl-defstruct phony--element-sequence
  "Element matching a sequence of sub-elements."
  elements)

(cl-defstruct phony--element-optional
  "Element matching ELEMENT zero or one times."
  element)

(cl-defstruct phony--element-repeat
  "Element that may match ELEMENT multiple times."
  element)

(cl-defstruct (phony--element-one-or-more
               (:include phony--element-repeat))
  "Element matching ELEMENT one or more times.")

(cl-defstruct (phony--element-zero-or-more
               (:include phony--element-repeat))
  "Element matching ELEMENT zero or more times.")

(cl-defstruct phony--element-argument
  "Element matching FORM and binding it to function argument NAME."
  (name nil
        :type symbol
        :documentation "Symbol naming the argument that captures the value of the match.")
  (form nil
        :type sexp
        :documentation "Form whose match will bind to the argument."))

(cl-defstruct phony--element-external-rule
  "Element matching some external rule.
Currently only relevant for the talon exporter."
  name namespace)

(cl-defstruct phony--element-rule
  "Element matching another rule."
  (name nil
        :type symbol
        :documentation "Symbol naming the phony rule that this element matches."))

(defun phony--parse-speech-value-element (element-form)
  "Parse ELEMENT-FORM into a valued element.

Valued elements are those that get associated to a value when matched.
Only these elements may be bound to arguments."
  (cond
   ((symbolp element-form) (make-phony--element-rule
                            :name element-form))
   ((eq (car element-form) 'external-rule) (make-phony--element-external-rule
                                            :name (car (last (cdr element-form)))
                                            :namespace (butlast (cdr element-form))))
   ((symbolp (car element-form))
    (error "Not an argument nor element type: `%S' in form `%S'"
           (car element-form)
           element-form))
   (t (error "No parse for %S" element-form))))

(defun phony--parse-speech-element (element-form arglist)
  "Parse ELEMENT-FORM into an element.

ARGLIST is the list of argument names for the function being defined.
This is required for recognizing if a form should bind turn argument."
  (cond
   ((stringp element-form) (make-phony--element-literal
                            :string element-form))
   ((member (car-safe element-form) arglist) (make-phony--element-argument
                                              :name (car element-form)
                                              :form (phony--parse-speech-value-element
                                                     (cadr element-form))))
   ;; NOTE: The reader interprets ? as a character escape, so to use
   ;; it in the specification of the pattern we actually need to
   ;; match on the character after that, which we require to be
   ;; space.
   ((eq (car-safe element-form) ?\s) (make-phony--element-optional
                                      :element
                                      (make-phony--element-sequence
                                       :elements (mapcar
                                                  (lambda (subelement)
                                                    (phony--parse-speech-element
                                                     subelement arglist))
                                                  (cdr element-form)))))
   ((eq (car-safe element-form) '+) (make-phony--element-one-or-more
                                     :element
                                     (make-phony--element-sequence
                                      :elements (mapcar
                                                 (lambda (subelement)
                                                   (phony--parse-speech-element
                                                    subelement arglist))
                                                 (cdr element-form)))))
   ((eq (car-safe element-form) '*) (make-phony--element-zero-or-more
                                     :element
                                     (make-phony--element-sequence
                                      :elements (mapcar
                                                 (lambda (subelement)
                                                   (phony--parse-speech-element
                                                    subelement arglist))
                                                 (cdr element-form)))))
   (t (phony--parse-speech-value-element element-form))))

(defun phony--element-children (element)
  "Return all direct sub-elements of ELEMENT."
  (cl-typecase element
    (phony--element-sequence
     (phony--element-sequence-elements element))
    (phony--element-optional
     (list (phony--element-optional-element element)))
    (phony--element-zero-or-more
     (list (phony--element-zero-or-more-element element)))
    (phony--element-one-or-more
     (list (phony--element-one-or-more-element element)))
    (phony--element-argument
     (list (phony--element-argument-form element)))
    (t nil)))

(defun phony--collect (predicate element)
  "Return list of descendants of ELEMENT matching PREDICATE.

If ELEMENT matches PREDICATE, it will be part of the list.  Matches are
returned in the same order that they occur in ELEMENT."
  (let ((collected-children
         (seq-mapcat
          (apply-partially #'phony--collect predicate)
          (phony--element-children element))))
    (if (funcall predicate element)
        (cons element collected-children)
      collected-children)))

(defun phony--dependencies (rule-or-name)
  "Return list of names of the rules RULE-OR-NAME depends on."
  (phony--dependencies-implementation
   (phony--normalize-rule rule-or-name)))

(cl-defgeneric phony--dependencies-implementation (rule)
  "Return list of rule names RULE depends on.")

(cl-defmethod phony--dependencies-implementation ((rule phony--procedure-rule))
  "Return list of rule names RULE depends on.

Rules in the list occur the same amount of times they are referenced in
RULE."
  (seq-map #'phony--element-rule-name
           (phony--collect
            #'phony--element-rule-p
            (phony--procedure-rule-element rule))))

(cl-defmethod phony--dependencies-implementation ((rule phony--open-rule))
  "Return names of the alternatives of RULE."
  (phony--open-rule-alternatives rule))

(cl-defmethod phony--dependencies-implementation ((_rule phony--dictionary))
  "Return nil."
  '())

(cl-defstruct (phony--analysis-data
               (:constructor nil)
               (:constructor phony--make-analysis-data))
  "Storage struct for results of statically analyzing the grammar."
  (forward
   (make-hash-table)
   :type hash-table
   :documentation "Hash table mapping a rule to a list of its dependencies.
If a dependency is referred to multiple times, it is duplicated.")
  (backward
   (make-hash-table)
   :type hash-table
   :documentation "Hash table mapping a rule to a list of its dependents.
If a dependent refers to a rule multiple times, it is duplicated.")
  (cycle
   nil
   :type (repeat symbol)
   :documentation "If non-nil, a sequence of rule names forming a dependency cycle.")
  (contains-errors
   nil
   :type boolean
   :documentation "Whether the analysis detected errors in the grammar.")
  (linear-extension
   nil
   :type (repeat symbol)
   :documentation "Linear extension of the dependency graph.
Also commonly known as topological order.  Rules occurring in this list
are guaranteed to only depend on preceding rules."))

(defun phony--backward-references (analysis-data rule-or-name)
  ;; checkdoc-params: (analysis-data)
  "Get list of rules referring to RULE-OR-NAME.

If a rule refers to RULE-OR-NAME. multiple times, it will also occur as
many times in the returned list."
  (gethash (phony--normalize-rule rule-or-name)
           (phony--analysis-data-backward analysis-data)))

(defun phony--forward-references (analysis-data rule-or-name)
  ;; checkdoc-params: (analysis-data)
  "Get list of rules referred to by RULE-OR-NAME.

If a rule is referred to by RULE-OR-NAME. multiple times, it will also
occur as many times in the returned list."
  (gethash (phony--normalize-rule rule-or-name)
           (phony--analysis-data-forward analysis-data)))

(defun phony--maximum-backward-multiplicity (analysis-data rule)
  ;; checkdoc-params: (analysis-data)
  "Return maximum amount of times RULE is referred to by a single rule."
  (thread-last
    (phony--backward-references analysis-data rule)
    (seq-map #'phony--rule-name)
    (seq-map #'symbol-name)
    (seq-sort #'string<)
    (seq-group-by #'identity)
    (seq-map #'cdr)
    (seq-map #'length)
    (apply #'max 0)))

(defun phony--populate-dependency-graph (analysis-data)
  "Populate the dependency graph of ANALYSIS-DATA.

If an undefined rule is referenced in some element, a warning will be
emitted and `phony--analysis-data-contains-errors' will be set to nil."
  (let ((dependencies (make-hash-table))
        (dependents (make-hash-table)))
    (seq-doseq (rule (phony--get-rules))
      (puthash rule '() dependencies)
      (puthash rule '() dependents))
    (seq-doseq (rule (phony--get-rules))
      (seq-doseq (dependency (phony--dependencies rule))
        (setq dependency (phony--get-rule dependency))
        (if (not dependency)
            (progn
              (display-warning 'phony
                               (format "Rule %S (referenced in %S) is not defined"
                                       dependency (phony--rule-name rule)))
              (setf (phony--analysis-data-contains-errors analysis-data) t))
          (push (phony--get-rule dependency) (gethash rule dependencies))
          (push rule (gethash dependency dependents)))))
    (setf (phony--analysis-data-forward analysis-data)
          dependencies)
    (setf (phony--analysis-data-backward analysis-data)
          dependents)))

(defun phony--try-linear-extension-impl (rule visited finished analysis-data)
  "Find linear extension of dependency graph in ANALYSIS-DATA.

This function assumes that `phony--analysis-data-forward' has been
populated in ANALYSIS-DATA.

This function populates `phony--analysis-data-linear-extension' in
ANALYSIS-DATA.  If a cycle is detected
`phony--analysis-data-contains-errors' is set to t and the cycle is
returned without visiting any more rules.  Otherwise, this function
returns nil.

RULE is the currently visited rule.  VISITED is a hash table of the
already visited rules.  FINISHED is a hash table of rules that have been
fully processed.  This function adds RULE to VISITED before recusing to
its children, and to FINISHED afterwards."
  (let ((successors (phony--analysis-data-forward analysis-data)))
    (cl-block nil
      (when (gethash rule finished)
        (cl-return nil))
      (when (gethash rule visited)
        (cl-return (list rule)))

      (puthash rule t visited)
      (seq-doseq (successor (gethash rule successors))
        (when-let ((path (phony--try-linear-extension-impl
                          successor visited finished analysis-data)))
          (if (and (not (length= path 1))
                   (eq (seq-first path) (car (last path))))
              (cl-return path)
            (cl-return (cons rule path)))))

      (puthash rule t finished)
      (push rule (phony--analysis-data-linear-extension analysis-data))
      (cl-return nil))))

(cl-defun phony--try-linear-extension (analysis-data)
  "Try to construct the linear extension of dependency graph.

This function assumes that `phony--analysis-data-forward' has been
populated in ANALYSIS-DATA.

If it is not possible to create a linear extension because of a cycle,
`phony--analysis-data-cycle' of ANALYSIS-DATA is set to that cycle and
`phony--analysis-data-contains-errors' is set to t.  Otherwise,
`phony--analysis-data-linear-extension' is populated with a valid linear
extension."
  (let ((visited (make-hash-table))
        (finished (make-hash-table)))
    (seq-doseq (rule (phony--get-rules))
      (when-let ((cycle (phony--try-linear-extension-impl
                         rule visited finished
                         analysis-data)))
        (setf (phony--analysis-data-cycle analysis-data)
              (seq-map #'phony--rule-name cycle))
        (cl-return-from phony--try-linear-extension)))))

(defvar phony--last-analysis nil
  "Results of the last performed analysis.")

(defun phony--analyze-grammar ()
  "Analyze the grammar.

This returns a `phony--analysis-data' structure populated with the
results of the analysis."
  (let ((analysis-data (phony--make-analysis-data)))
    (phony--populate-dependency-graph analysis-data)
    (phony--try-linear-extension analysis-data)
    (setf (phony--analysis-data-linear-extension analysis-data)
          (reverse
           (phony--analysis-data-linear-extension analysis-data)))
    (when-let (cycle (phony--analysis-data-cycle analysis-data))
      (display-warning 'phony (concat "Cycle found: "
                                      (string-join
                                       (seq-map #'symbol-name cycle)
                                       " -> ")))
      (setf (phony--analysis-data-contains-errors analysis-data) t))
    (setq phony--last-analysis analysis-data)
    analysis-data))

(defun phony--dependents (rule-or-name)
  "Return dependents of RULE-OR-NAME.

This function depends on `phony--last-analysis'.  If an analysis has not
been performed, the returned value may be out of date."
  (gethash
   (phony--normalize-rule rule-or-name)
   (phony--analysis-data-backward phony--last-analysis)))

(defcustom phony-export-function #'phony-talon-export
  "Function to be used for exporting spoken rules."
  ;; Using radio instead of choice did not display :tag
  :type '(choice (function-item :tag "Dragonfly exporter"
                                phony-dragonfly-export)
                 (function-item :tag "Talon exporter"
                                phony-talon-export))
  :tag "Phony Rule Exporter"
  :risky t
  :group 'phony)

(defun phony--export-all ()
  "Export all rules to the speech recognition engine.

If any errors are detected in the grammar, the rules are not exported."
  (let ((analysis-data (phony--analyze-grammar)))
    (if (phony--analysis-data-contains-errors analysis-data)
        (display-warning 'phony "Grammar contains errors, not exporting")
      (phony--export-dictionaries)
      (funcall phony-export-function analysis-data))))

(defun phony-request-export ()
  "Export all rules when next idle."
  (interactive)
  (cancel-function-timers #'phony--export-all)
  (run-with-idle-timer 0 nil #'phony--export-all))

(cl-defun phony--export-rule (function
                              arglist
                              element-forms
                              &key
                              (mode 'global)
                              (contributes-to nil)
                              (external-name nil)
                              (export t)
                              (anchor-beginning nil)
                              (anchor-end nil))
  ;; checkdoc-params: (mode contributes-to external-name export anchor-beginning anchor-end)
  "Declare FUNCTION to be a rule invokeable by voice.

ARGLIST is the argument list of the function.  ELEMENT-FORMS is a list of
element forms specifying how to match this rule.

For the named arguments and the specification of element forms, see the
documentation for `phony-rule'."
  (setq arglist (byte-compile-arglist-vars arglist))
  (setq mode (ensure-list mode))
  (setq external-name (or external-name (phony--to-python-identifier function)))
  (phony-remove-rule function)
  (let* ((elements
          (seq-map (lambda (element)
                     (phony--parse-speech-element element (byte-compile-arglist-vars arglist)))
                   element-forms)))
    (phony--add-rule
     (make-phony--procedure-rule
      :name function
      :external-name external-name
      :function function
      :element (make-phony--element-sequence
                :elements elements)
      :arglist arglist
      :modes mode
      :export export
      :anchor-beginning-p anchor-beginning
      :anchor-end-p anchor-end))

    (seq-doseq (to (ensure-list contributes-to))
      (phony--add-alternative function to))

    (phony-request-export)))

(cl-defun phony--speech-declaration (function arglist &rest declaration-args)
  ;; checkdoc-params: (arglist declaration-args)
  "Declare FUNCTION to be a rule invokeable by voice.

This function should not be called directly, but through a `phony-rule'
form."
  (let* ((split-args (phony--split-keywords-rest declaration-args))
         (keyword-arguments (car split-args))
         (pattern (cdr split-args)))
    `(phony--export-rule
      #',function
      ',arglist
      ',pattern
      ,@keyword-arguments)))

(setf (alist-get 'phony-rule defun-declarations-alist)
      (list #'phony--speech-declaration))

(defmacro phony-rule (args)
  ;; checkdoc-params: (args)
  "Declare function to be a rule invokeable by voice.

This form must occur inside a `declare' form to take effect.

ELEMENTS is a sequence of elements declaring when this rule gets
matched.  An element may have one of the following forms:

  STRING           Match a literal STRING.
  SYMBOL           Match a rule named SYMBOL.
  (ARG SYMBOL)     Match a rule named SYMBOL, bind its value to argument
                   ARG.  ARG must be part of the function's arglist.
  (? ELEMS...)     Optionally match elements ELEMS.
  (* ELEMS...)     Match elements ELEMS zero or more times.
  (+ ELEMS...)     Match elements ELEMS one or more times.

Optional arguments for the rule are given before ELEMENTS as a sequence
of alternating KEY and VALUE.  Optional arguments are:

  :export            If nil, this rule cannot be spoken directly but may
                     occur as part of other rules.  Default is t.
  :mode              A mode or list of modes for this rule should be
                     active.  Only relevant for exported rules.  Default
                     is 'global.
  :contributes-to    A symbol or list of symbols of open rules that this
                     procedure should contribute to.  See
                     `phony-define-open-rule' for open rules.  Default
                     is nil.
  :anchor-beginning  If t, this rule must occur first in an utterance.
                     Default is nil.
  :anchor-end        If t, this rule must occur last in an utterance.
                     Default is nil.

\(fn [KEY VALUE]... ELEMENTS...)"
  `(message "Stray `phony-rule' form: %S" '(phony-rule . ,args)))

(require 'phony-talon)
(require 'phony-dragonfly)

(provide 'phony)
;;; phony.el ends here
