#+title: phony.el
Bindings for defining voice commands in Emacs.

* Illustrative example
After having set up this package, you will be able to define voice
commands like this:

#+begin_src elisp
  (defun rule/say-hello ()
    (declare (phony-rule "hello emacs"))
    (message "Hello!"))
#+end_src

With such a function defined, uttering "hello emacs" will display
"Hello!" in the message area.  Commands may, of course, perform much
more complex actions than this.

* Setup
Add the following to your Emacs configuration:

#+begin_src elisp
  (use-package phony
    :vc (:url "https://github.com/ErikPrantare/phony.el"
              :branch "master"
              :rev :newest)
    :config
    (setopt phony-output-directory "my/directory/of/choice"))
#+end_src

, where ~"my/directory/of/choice"~ is replaced with the path to the
directory where you want phony to write the rules for the speech
engine.

** Command evaluator
Install the command evaluator from the EmacsListen repository.

** Speech recognition backend
Phony currently supports the following speech recognition backends:

- Dragonfly
- Talon

Dragonfly is recommended over Talon, as Dragonfly is Free Software
while Talon is proprietary.  However, phony works better for Talon
on a purely technical level.

*** Dragonfly
First, install dragonfly with the Kaldi engine.  Instructions here
(no need to try out the demos in the Kaldi installation instructions).

Then, add the following to your Emacs configuration, substituting the
values with paths of your choice:

#+begin_src elisp
  (setopt phony-dragonfly--rule-output-file "path/to/rule/output.json")
  (setopt phony-dragonfly--model-path "path/to/model")
  (setopt phony-dragonfly--config-output-file "path/to/config/output.json")
  (setopt phony-export-function #'phony-dragonfly-export)
#+end_src

Finally, invoke the script provided in [[file:dragonfly/read_rules.py]] to
start the engine:

#+begin_src sh
  python dragonfly/read_rules.py --config "path/to/config/output.json"
#+end_src

*** Talon
Install talon and add the following to your Emacs configuration:

#+begin_src elisp
  (setopt phony-export-function #'phony-talon-export)
#+end_src

~phony-output-directory~ has to be set to a subdirectory of the talon
user directory.  Phony will generate files in this subdirectory, so
set it to a directory that does not contain any other user
configuration.

* Usage
You can now define talon lists using the ~phony-define-dictionary~
macro.  It takes two mandatory arguments: An emacs identifier for
storing the list and an alist mapping utterances to values.

The macro will define the variable given as its first argument and
store the alist in it, making it available for use in Elisp.  It will
also notify talon that the lists have been updated, causing talon to
read the defined lists.  After this, the lists will become available
for usage in talon files.

You can also define more complex rules.  See the documentation for
~phony-rule~ for more information.

* Example usage
** Create list mapping spoken form of colors to hexcode
In emacs:

#+begin_src emacs-lisp
  (phony-define-dictionary my/colors
    :external-name "color"
    '(("white" . "#fffff")
      ("black" . "#000000")
      ("red" . "#ff0000")))
#+end_src

In talon:

#+begin_src talon
  insert color {user.color}:
      user.emacs_lisp("(insert {color})")
#+end_src

** Create list of commands
In emacs:

#+begin_src emacs-lisp
  (phony-define-dictionary my/commands
    :external-name "command"
    `(("save" . ,#'save-buffer)
      ("hello" . ,(lambda () (message "Hello %s!" (user-full-name))))))
#+end_src

In talon:

#+begin_src talon
  {user.command}:
      user.emacs_lisp("(funcall {command})")
#+end_src

* Accessing and modifying defined lists
To access the value corresponding to an utterance, use the function
~phony-dictionary-get~.  This is a generalized variable, meaning you
can use ~setf~ to modify elements of it:

#+begin_src elisp
  (setf (phony-dictionary-get "squash" my/colors) 'yellow)
#+end_src

This form allows you to add, remove and change values in the list.
Removing an element is done by setting it to nil.  After modifying a
list, the changes will automatically sync with talon.

* Versioning system
This project uses [[https://semver.org/][semantic versioning]].  While still on 0.y.z, an
increment of y signals breaking changes.
