#+title: phony.el
Bindings for defining voice commands in Emacs.

* Illustrative example
After having set up this package, you will be able to define voice
commands like this:

#+begin_src elisp
  (defun rule/say-hello ()
    (declare (phony-rule "hello emacs"))
    (message "Hello!"))
#+end_src

With such a function defined, uttering "hello emacs" will display
"Hello!" in the message area.

* Supported speech recognition backends
Phony currently only supports Talon.  If you want to help with adding
support for Dragonfly with kaldi-active-grammar to allow this to be
used with [[https://www.gnu.org/philosophy/free-sw.html][Free Software]], you can get in contact by opening an issue or
sending a message in the dragonfly matrix room or the emacs channel on
the talon slack.

* Setup
Add the following to your Emacs configuration:

#+begin_src elisp
  (use-package phony
    :vc (:url "https://github.com/ErikPrantare/phony.el"
              :branch "master"
              :rev :newest))
#+end_src

* Usage
There are three types of rules: procedure rules, open rules, and
dictionaries.  They are different ways of specifying how utterances
should produce values and side effects.

** Procedure rules
Procedure rules map your spoken utterances to code.  Procedure rules
are declared in the ~declare~ form of a ~defun~.  With the following
example, uttering "hello emacs" will display "Hello!" in the message
area:

#+begin_src elisp
  (defun rule/say-hello ()
    (declare (phony-rule "hello emacs"))
    (message "Hello!"))
#+end_src

Procedure rules can produce values.  Other rules can refer to
value-producing rules and bind their values to the arguments of the
function.  In the following code example, ~rule/current-line~ defines
a rule matching "line" and returning the region of the current line.
It declares ~:export nil~ to avoid "line" by itself to be matched,
making it only possible to match when referred to by another rule.

The two rules ~rule/delete-current-line~ and
~rule/beginning-of-current-line~ make use of ~rule/current-line~ to
bind their argument to its return value.  Thus, saying "delete line"
will delete the current line and saying "beginning of line" will move
point to the beginning of the current line.

#+begin_src elisp
  (defun rule/current-line ()
    (declare (phony-rule
              :export nil
              "line"))
    (bounds-of-thing-at-point 'line))

  (defun rule/delete-current-line (bounds)
    (declare (phony-rule
              "delete"
              (bounds rule/current-line)))
    (delete-region (car bounds) (cdr bounds)))

  (defun rule/beginning-of-current-line (bounds)
    (declare (phony-rule
              "beginning of"
              (bounds rule/current-line)))
    (goto-char (car bounds)))
#+end_src

For more documentation on procedure rules, see the function
documentation of ~phony-rule~.

** Dictionaries
Dictionaries are utterance -> value maps.  The following code defines
a dictionary for the first five numbers:

#+begin_src elisp
  (phony-define-dictionary rule/number
    '(("one" . 1)
      ("two" . 2)
      ("three" . 3)
      ("four" . 4)
      ("five" . 5)))
#+end_src

These are usefully referred to by procedure rules.  With the following
procedure rule, uttering "delete three lines" will delete three lines,
and correspondingly for any other number between one and five.

#+begin_src elisp
  (defun rule/delete-lines (n)
    (declare (phony-rule
              "delete"
              (n rule/number)
              "lines"))
    (dotimes (i n)
      (delete-line)))
#+end_src

For more information on dictionaries, see the function documentation
for ~phony-define-dictionary~.

** Open rule
An open rule is a way to match on any one of multiple rules.  In the
following code example, one may utter "delete line" to delete the
current line, or "delete sentence" to delete the current sentence:

#+begin_src elisp
  (defun rule/current-line ()
    (declare (phony-rule
              :export nil
              "line"))
    (bounds-of-thing-at-point 'line))

  (defun rule/current-sentence ()
    (declare (phony-rule
              :export nil
              "sentence"))
    (bounds-of-thing-at-point 'sentence))

  (phony-define-open-rule rule/region
    :alternatives '(rule/current-line rule/current-sentence))

  (defun rule/delete-current-line (bounds)
    (declare (phony-rule
              "delete"
              (bounds rule/region)))
    (delete-region (car bounds) (cdr bounds)))
#+end_src

Instead of explicitly listing all alternatives, other rules can add
themselves to an open rule.  This is a good way of providing
extensibility for your grammars.  The next code example is identical
in effect to the previous one:

#+begin_src elisp
  (phony-define-open-rule rule/region)

  (defun rule/current-line ()
    (declare (phony-rule
              :contributes-to 'rule/region
              :export nil
              "line"))
    (bounds-of-thing-at-point 'line))

  (defun rule/current-sentence ()
    (declare (phony-rule
              :contributes-to 'rule/region
              :export nil
              "sentence"))
    (bounds-of-thing-at-point 'sentence))

  (defun rule/delete-current-line (bounds)
    (declare (phony-rule
              "delete"
              (bounds rule/region)))
    (delete-region (car bounds) (cdr bounds)))
#+end_src

For more information on open rules, read the function documentation
for ~phony-define-open-rule~.

* Bindings for talon community rules
If you're using talon community, some basic bindings are given in
~phony-talon-community-bindings.el~.  Add

#+begin_src elisp
  (require 'phony-talon-community-bindings)
#+end_src

to your configuration to import them.

* Versioning system
This project uses [[https://semver.org/][semantic versioning]].  While still on 0.y.z, an
increment of y signals breaking changes.
